\section*{Problem Statement}
\thispagestyle{empty}
\textit{For thesis on Property-Based Testing of Reactive Programs}\\
\textit{written by Lukas Dannebrog Jensen}\\
\textit{supervised by Patrick Bahr}\\
\textit{submitted on February 24, 2023} \par
Programming at any levels will inevitably produce some erroneous code. The cost of programming errors found post-release can be everything from a passenger airplane crashing  to millions of annoying browser reloads. Therefore testing software to find errors pre-release is hugely important. \par 
In the most common form of testing, called unit testing, the programmer defines a set of test cases that are then checked. Unfortunately generating suitable test cases and expected output to check against is laborious, and difficult.
property-based testing (PBT), takes a different approach. In PBT the programmer defines a set of properties, that specify desired behaviors for many if not all different input values, and then tools like QuickCheck (\cite{quickCheck}) generate random test cases and checks fulfillment of the properties. $f_{old} (x) = f_{new} (x) \forall x $ is an example of a property that works for doing regression testing.
QuickCheck is implemented as a Domain Specific Language (DSL) in Haskell and utilizes Haskell’s type system to come up with suitable test cases. However, some programming paradigms implemented in specific languages does not have tools like QuickCheck at hand. \par
An example of such a language is the functional reactive programming language Rattus (\cite{rattus}). Rattus is also implemented as a DSL in Haskell. In FRP the basic components are signals. Signals models time-varying values, like prices,  physical measurements, disease incidents etc. In functional programming a signal is represented as function that a takes a time and returns a value, this is an issue because a property on a signal that holds now, might not hold tomorrow. 
“Arrowised” FRP languages solves this by using signal functions instead of signals themselves (\cite{yampa}), and there PBT has been be employed (\cite{runtimeVerification}). Unfortunately signal functions quickly leads to reduced code comprehensibility. \par
The goal for this thesis is to create a prototype for a PBT tool for Rattus, inspired by the specifications and implementations of QuickCheck in Haskell and the PBT implementation for an Arrowised language.
My deliverables will be a repository with the source code for the prototype along with the architectural description, key parts of which will be presented in a thesis document along with examples of usage.

