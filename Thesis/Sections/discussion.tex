\section{Discussion}
\subsection{Generating signals}
QuickChecks ability to generate sensible inputs is crucial. Inputs to functions in FRP are often signals and therefore previous work has dealt with the problem of generating sensible signals in various ways.
\par
\cite{runtimeVerification}'s solution is somewhat different from ours because the library is based  on continuous streams and uses finite streams for testing as which is reflected in listing \ref{lst:strGenRV}. Therefore, testers must specify a distribution and range for time-sampling, as well as the length of the finite stream. Time samplling is out of our control so the essential part is the first argument of type \verb|(Int -> DTime -> Gen a)| 
the semantics for this function is to return a generator for an element in the stream given the sample count and time since last sample. Their solution is easy to comprehend, but passes majority of the work on implementing a suitable generator on to the tester.
\begin{figure}[H]
    \centering
    \begin{hscode}
    generateStreamWith :: Arbitrary a
                        => (Int -> DTime -> Gen a) 
                        -> Distribution 
                        -> Range 
                        -> Length
                        -> Gen (SignalSampleStream a)
    \end{hscode}
    \caption{Stream generation in \cite{runtimeVerification}}
    \label{lst:strGenRV}
\end{figure}
\par 
Quickstrom \parencite{quickstrom} solves a similar problems, where it generates streams of button click, this is because Quickstrom is built for property based testing of UIs. The expected behavior is defined in an LTL dialect. An example of such a tester defined behavior is 
$$
    \mathbf{G} (\text{dark} \wedge \mathbf{X} \text{light} \vee \text{light}  \wedge \mathbf{X} \text{dark})
$$
which states that the GUI should flicker between dark and light, in the next step tester specifies which user actions are of interest, this could be clicks on buttons a b. Finally creates a stream of random potential button clicks and checks that is is not possible to find a counter example, to the property. Unfortunately quickstrom does not deal with more complex problem of creating a generator of streams for types different from booleans.





