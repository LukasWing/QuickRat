\section{Technical}
To use PBT on functions whose input are Rattus Streams \verb|Str a| with QuickCheck we must implement an instance of \verb|Arbitrary| for \verb|Str a| and implement some notion of equality for \verb|Str a|.
\subsection{Stream evaluators}
Because a \verb|Str| is infinite, we can never know whether they are truly equal by comparing values, we therefore need to implement a notion of "probably equal", a simple solution is to check for equality for elements in a finite part. Doing so requires, that \verb|a| implements \verb|Eq|.
Suppose we do regression testing and we have \verb|f| and \verb|f'| with type signature of.
\verb|Str a -> Str b|. 
We can sensibly test for the properties the \verb|f| is equal to \verb|f'|.
\subsubsection{Examples}
A key type in making the evaluator is the polymorphic type \verb|Stamate a|, a Stamate is an algebraic datatype which be either Pass, Fail or NextT the NextT value constructor takes function of type a -> Stamate a, an thus a Stamate can be i a tree where each internal vertex has two leaves, representing passs or fail, and a third child which the next internal vertex. Another to think of it is a state machine, equipped with a next-state function:  \verb|Stamate a -> Str a -> Stamate a|. The next state function is run recursively, and for each call the stream is advanced, after finish the is function that maps the resulting Stamate to a boolean.
Consider the following example.
Suppose we wish to build a function that tests whether $\pi \vDash p \wedge \mathbf{X} q $ when $\pi: 1, 2, 1, 2, 1, 2, \dots$; $p$: The head is odd; and $q$: The head is even. A truth table for and formula, with some example inputs would
\begin{table}[H]
    \centering
    \begin{tabular}{lcccc}
    \toprule
    Example            &  $p$   &  $q$ & $\mathbf{X} q $&$  p \wedge \mathbf{X} q$ \\   
    \midrule
         $2,2,3,\dots $ &  $F$   &  $T$ & $           T $&$                  F $\\
         $1,2,3,\dots $ &  $T$   &  $F$ & $           T $&$                  T $\\
         $1,3,8,\dots $ &  $T$   &  $F$ & $           F $&$                  F $ \\
    \bottomrule
    \end{tabular}
    \caption{Truthtable of \acrshort{ltl}-formular satisfisfaction}
    \label{tab:LTLSatExample}
\end{table}
A Stamate for q would be
\begin{hscode}
    q = NextT (\x -> if even x then Pass else Fail)
    p = NextT (\x -> if odd x then Pass else Fail)
\end{hscode}


% A stamate with this behavior would be:
% qAndp = NextT (\x1 -> if even x1 
%                         then (NextT(\x2 -> if odd x2 then Pass else Fail)) 
%                         else Fail)
% q `And` p (1,2,3,4):: 

% (NextT fq) `And` (NextT fp) (x1,x2,x3,x4) = 
%     NextT \$ case fq x1 of 
%         Pass -> (\_ -> NextT(\x2 -> if odd x2 then Pass else Fail)
%         Fail -> Fail
%         NextT -> Error "An Int is either odd or even".

% (NextT fq) `And` (NextT fp) (x1,x2,x3,x4) = NextT fp
%                                           = (\_ -> NextT(\x2 -> if odd x2 then Pass else Fail)
%                                           = NextT (\x2 -> if odd x2 then Pass else Fail)
%                                           = Pass else Fail
        
\subsubsection{Syntax}
\subsubsection{Implementation}


\subsection{Stream generators}
PBT on functions whose input and/or output are Rattus Streams requires generators and stream evaluators. The simplest make a random stream is to implement arbitrary  by creating a \verb|Str a| where each is value is generated by \verb|Gen a|.
\ref{lst:ArbStr} Does exactly that, by recursively setting the head of the stream to be an arbitrary value of the type \verb|a|, note how the absence of a stopping condition demonstrates Haskell's laziness. 
\begin{figure}
    \begin{hscode}
        instance (Arbitrary a) => Arbitrary (Str a) where
        arbitrary = do
            x <- arbitrary::Gen a
            xs <- arbitrary::Gen (Str a)
            return \$ x:::delay xs
    \end{hscode}
    \caption{Arbitrary's instance definition of Str a}
    \label{lst:ArbStr}
\end{figure}
\ref{lst:ArbStr} can only produce streams of independent independent values. But such streams, does not usually model the problem domain well. Therefore I use a state machine, like the following.
\subsubsection{Examples}
\subsubsection{Implentation}
...