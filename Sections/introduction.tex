\section{Introduction}
\subsection{Motivation}
\par I bet most of the people at some point has had an idea for a piece of software, this could be anything from an egg timer app to a program that knows the entire internet and can be prompted in natural language. Getting such ideas take only little effort, but it takes more effort to get it to work once, even more effort to get to work reliably, and even more so to guarantee for correctness of programs. Along this continuum from working once to guaranteed correctness, each program ends up at some balance point between between workload and correctness.
What will be presented in thesis is a testing tool, called QuickRat, which in a specific domain of programming, can lower the workload to make programs more reliable. Which in turn may shift balance point by just a bit.

\par QuickRat is an implementation of ideas largely formulated in mathematics and natural language, so despite the narrowness of QuickRat its key ideas are widely applicable. QuickRat is written in the pure functional programming language Haskell and is intended for testing functions that uses \acrfull{frp}. \acrshort{frp} is a programming paradigm originally described for animations \parencite{fran}. In \acrshort{frp} time varying behavior is the primary concern, to model these behaviors, time dependent functions rather than values are used. The signature of such functions are $f:\, \mathbb{R} \rightarrow C$, where time is a real number and C is any relevant co-domain. $f$ represents a time varying value is which is called a signal (or behavior). Consider a scheduler as an example, a scheduler is expected to always tell, which thread is active. Stated a more mathematically for every possible time in the real numbers, the scheduler serves as a signal of which thread in the set of possible threads $T$ is active, symbolically this is expressed as $s:\mathbb{R} \rightarrow T$. 

\par Signals models many aspects of the world, since so much varies with time. And therefore implementing functions that take signals as input or returns them as outputs is of key interest. And there exist many different libraries/languages for doing so, one of which is Rattus\parencite{rattus}, which is used in this thesis and will be introduced further in background section, another is Yampa\parencite{yampa}, whish will also be mentioned.  as an example of a situattion th can be modelled by \acrshort{frp}, consider for example a factory with a boilertank, that produces a signal with a pressure sensor reading. For safety reasons we need a function that returns a boolean signal, to a blowoff valve. The signature would be 
\begin{align*}
    f:&\, s_{p} \rightarrow s_{v} \text{  where}\\
    s_{p}:&\, \mathbb{R} \rightarrow \mathbb{R_+}\\ 
    s_{v}:&\, \mathbb{R} \rightarrow \{0,1\}.
\end{align*}
By modelling with signals we get a comprehensible signature of $s$, but implementation can still have errors and for a safety critical system such as this, we need reliable code, en hence tests. 
\par  If you see the semantics of a functions as something that takes an input, and then returns an output, then your natural way to test it would be to define an input, and somehow check, that the output is what you expected. That approach taken in unit testing, and unit-test could have gotten us a long way, if the blowoff-valve should only look at the current reading to determine whether the valve should be open, hence we would get a signature of $f_{alt}:\mathbb{R_+} \rightarrow \{\text{open},\text{closed}\}$. But for $f$ the specification might be:
\begin{enumerate}
    \item If at some point the the pressure gets above some threshold $t$ then the blowoff valve is activated immediately.
    \item If the pressure gets above a the threshold the valve is on until the pressure gets below $t$.
    \item If the pressure drops below $t$ and stays below, the pressure valve eventually becomes inactive.
    \item If the pressure never gets above p $t$ the blowoff valve is never activated.
\end{enumerate}
because such specifications are more focused on properties of $f$ these are very hard and cumbersome to test for using only a finite set of test cases. But a promising solution is to use \acrlong{pbt}.

\par In \acrshort{pbt} the tester does not need manually create the entire set of test-cases. Instead a property that should hold for any outputs from for a subset of possible inputs is given. Unfortunately both specifying the input and the the properties of the output, when any of those are signals, usually takes a lot of work, because you need to deal with variability over time, rather than static inputs. For so called Arrowised-FRP there has been made an implementation\parencite{runtimeVerification}, that makes assertion creation easy. These assertions are specified in a time-dependent logic known as \acrfull{ltl}. \acrshort{ltl} logice for making formulas, such that any signal is either accepted or not, just like formulas in propositional logic can accept any complete value assignment in its scope.

\subsection{Key Ideas}
\par While \parencite{runtimeVerification,quickstrom} shows \acrshort{ltl} as promising, but extending \acrshort{ltl} use into the process of generating suitable test inputs has not been achieved, neither with Rattus or other FRP library. This thesis introduces QuickRat which at its core consists of
\begin{enumerate}
    \item A definition of  \acrshort{ltl} syntax, as a type in Haskell.
    \item A function that from any  \acrshort{ltl} formula can create a signal acceptor.
    \item Functionality that for any  \acrshort{ltl} formula can create a signal generator.
\end{enumerate}
Here is a simple code example which test propperty 4 with 100 generated cases.
\begin{hscode}
f :: Str Int -> Str Bool
f aStr = ...
prop_f_pBelow10_vAlwaysOff :: Property
prop_f_pBelow10_vAlwaysOff =
    forAll
        (trans \$ (mkTransducer . mkAcceptor) (Always (Atom (<10))))
        \$ \aStr -> accept (f aStr) (mkAcceptor (Always (Atom not)))
    -- or
    
ghci> quickCheck prop_f_pBelow10_vAlwaysOff
\>\>\> +++ OK, passed 100 tests.
\end{hscode}
The atom represents some property of signal output, that is true or false. While this code looks simple there are some caveats, some stems from the fact, that signals are infinite, where checking is only done for a finite part, while others stems from input generation being infeasible, when atoms only are only true for a small fraction of possible inputs, these caveats will be treated in discussion section.
